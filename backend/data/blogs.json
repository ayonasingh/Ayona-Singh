[
    {
        "id": "b1",
        "tag": "Calculus",
        "date": "Feb 10, 2026",
        "readTime": "5 min read",
        "title": "Understanding Limits & Continuity in Real Analysis",
        "excerpt": "Limits are the backbone of calculus. In this post I break down what limits really mean, how to evaluate them, and why continuity matters so much in analysis.",
        "image": "",
        "link": "#",
        "content": "## What Are Limits?\n\nA limit describes the value that a function approaches as the input approaches a particular point. Formally, we write:\n\n**lim (x → a) f(x) = L**\n\nThis means: as x gets arbitrarily close to a (but never equals a), f(x) gets arbitrarily close to L.\n\n## Why Do Limits Matter?\n\nLimits are the very foundation of calculus. Without limits, we cannot define derivatives or integrals — the two core operations of calculus. Every time you compute a derivative using the definition:\n\n**f'(x) = lim (h → 0) [f(x+h) - f(x)] / h**\n\n…you are taking a limit.\n\n## Types of Limits\n\n**One-sided limits:** We say the left-hand limit exists if f(x) approaches L as x approaches a from the left (x → a⁻), and similarly for the right-hand limit (x → a⁺).\n\n**Infinite limits:** When f(x) grows without bound as x → a, we write lim f(x) = ∞. This usually indicates a vertical asymptote.\n\n**Limits at infinity:** We ask what happens to f(x) as x → ∞ or x → −∞. This tells us about horizontal asymptotes.\n\n## Continuity\n\nA function f is continuous at a point a if three conditions hold:\n1. f(a) is defined\n2. lim (x → a) f(x) exists\n3. lim (x → a) f(x) = f(a)\n\nIntuitively, a function is continuous if you can draw its graph without lifting your pencil.\n\n## Common Pitfalls\n\nStudents often confuse the limit of f at a with the value of f at a. Remember: a limit describes *approach*, not arrival. f(a) might not even be defined, yet the limit can still exist!\n\n## Conclusion\n\nMastering limits is the first real milestone in studying calculus. Once you understand how functions *behave* near a point, differentiation and integration become natural extensions of that understanding.",
        "createdAt": "2026-02-10T00:00:00.000Z"
    },
    {
        "id": "b2",
        "tag": "Statistics",
        "date": "Jan 28, 2026",
        "readTime": "6 min read",
        "title": "Demystifying Probability Distributions for Beginners",
        "excerpt": "From Binomial to Normal — understanding probability distributions can feel overwhelming. Here's a simple, visual guide to the most common ones used in statistics.",
        "image": "",
        "link": "#",
        "content": "## What Is a Probability Distribution?\n\nA probability distribution tells us how likely different outcomes are for a random variable. Think of rolling a fair die: each face (1 through 6) has a 1/6 chance of appearing. That's a discrete uniform distribution.\n\n## Discrete vs. Continuous\n\n**Discrete distributions** deal with countable outcomes — like the number of heads in 10 coin flips.\n\n**Continuous distributions** deal with uncountable outcomes — like the exact height of a randomly chosen person.\n\n## The Binomial Distribution\n\nUsed when you repeat the same experiment n times, each with probability p of success.\n\n**P(X = k) = C(n,k) · pᵏ · (1-p)ⁿ⁻ᵏ**\n\nExample: probability of exactly 3 heads in 10 fair coin flips.\n\n## The Normal Distribution (Bell Curve)\n\nThe most important distribution in statistics. Many natural phenomena — heights, test scores, measurement errors — follow a normal distribution.\n\nKey properties:\n- Symmetric around the mean μ\n- 68% of data falls within 1 standard deviation σ\n- 95% within 2σ, 99.7% within 3σ (the empirical rule)\n\n## The Poisson Distribution\n\nModels the number of events occurring in a fixed interval of time or space.\n\n**P(X = k) = (λᵏ · e⁻λ) / k!**\n\nExample: number of emails received per hour, or cars passing a point on a highway.\n\n## The Exponential Distribution\n\nModels the time between events in a Poisson process. If events occur at rate λ per unit time, the waiting time between events follows an Exponential(λ) distribution.\n\n## Why This Matters\n\nKnowing which distribution fits your data is the first step in statistical modeling. Choose the wrong distribution and your conclusions could be completely off. Always plot your data and check for skewness, outliers, and the nature of the variable (discrete or continuous).",
        "createdAt": "2026-01-28T00:00:00.000Z"
    },
    {
        "id": "b3",
        "tag": "Linear Algebra",
        "date": "Jan 15, 2026",
        "readTime": "7 min read",
        "title": "Eigenvalues, Eigenvectors & Why They Matter",
        "excerpt": "Eigenvalues are everywhere — from Google's PageRank to quantum mechanics. Let's explore what they are, how to compute them, and their real-world applications.",
        "image": "",
        "link": "#",
        "content": "## What Are Eigenvectors?\n\nGiven a square matrix A, a non-zero vector v is called an **eigenvector** if multiplying it by A only scales it — it doesn't change direction:\n\n**Av = λv**\n\nThe scalar λ is the corresponding **eigenvalue**.\n\n## Finding Eigenvalues\n\nTo find eigenvalues, we solve the **characteristic equation**:\n\n**det(A − λI) = 0**\n\nFor a 2×2 matrix, this gives a quadratic equation. For 3×3, cubic — and so on.\n\n## A Simple Example\n\nLet A = [[3, 1], [0, 2]].\n\nThe characteristic polynomial is (3 − λ)(2 − λ) = 0, giving eigenvalues λ₁ = 3 and λ₂ = 2.\n\nFor λ₁ = 3: solve (A − 3I)v = 0 → eigenvector v₁ = [1, 0]\nFor λ₂ = 2: solve (A − 2I)v = 0 → eigenvector v₂ = [1, −1]\n\n## Real-World Applications\n\n**Google PageRank:** The ranking of websites is computed as the dominant eigenvector of a massive link matrix.\n\n**Quantum Mechanics:** Observable quantities (energy, momentum) correspond to eigenvalues of quantum operators.\n\n**Principal Component Analysis (PCA):** Used in machine learning to reduce data dimensions. The principal components are eigenvectors of the covariance matrix.\n\n**Vibration Analysis:** In structural engineering, eigenvalues give the natural frequencies of a system.\n\n**Markov Chains:** The long-run distribution of a Markov chain is the eigenvector for eigenvalue 1.\n\n## Geometric Intuition\n\nMost vectors get both stretched AND rotated when multiplied by a matrix. Eigenvectors are special: they only get stretched (or flipped). They point along the *natural axes* of the transformation.\n\n## Conclusion\n\nEigenvalues and eigenvectors reveal the internal geometry of a linear transformation. Once you see how they appear in PCA, quantum mechanics, graph theory, and vibration analysis, you'll appreciate why they're called one of the most important concepts in all of mathematics.",
        "createdAt": "2026-01-15T00:00:00.000Z"
    },
    {
        "id": "b4",
        "tag": "Problem Solving",
        "date": "Jan 5, 2026",
        "readTime": "4 min read",
        "title": "My Top 5 Strategies for Cracking Math Olympiad Problems",
        "excerpt": "After competing in school-level Math Olympiads, I've picked up proven problem-solving strategies. Here are the five that helped me the most.",
        "image": "",
        "link": "#",
        "content": "## Why Olympiad Problems Are Different\n\nOlympiad math is not about memorizing formulas. It's about *creative reasoning* — finding elegant arguments that cut through complexity. Every problem is a puzzle, and the solution often hinges on a single key insight.\n\n## Strategy 1: Work With Small Cases\n\nWhen a problem involves a general statement for all n, start with n = 1, 2, 3. Look for a pattern. Sometimes the pattern gives away the proof strategy.\n\n## Strategy 2: Draw a Picture\n\nEven in pure algebra or number theory, a diagram can reveal structure that algebra hides. Geometry problems especially reward good diagrams with clearly labeled angles and lengths.\n\n## Strategy 3: Consider Extremes\n\nAsk: what happens when a variable is 0, 1, very large, or very small? Extremes often expose the core behavior of the problem and rule out wrong approaches.\n\n## Strategy 4: Invariants and Monovariants\n\nLook for a quantity that never changes (invariant) or always changes in one direction (monovariant). These are especially powerful in combinatorics and game problems.\n\nExample: In a coin-flipping game, track the parity of heads. If it's always even no matter what moves are made, you have an invariant.\n\n## Strategy 5: Reformulate the Problem\n\nSometimes a problem becomes easy once you translate it into a different domain. A number theory problem might have a beautiful geometric proof. An algebra problem might yield to combinatorial reasoning. Always ask: *can I see this differently?*\n\n## Practice Mindset\n\nDon't fear unsolved problems — they're where growth happens. Spend at least 30 minutes stuck before looking at hints. Write down your thoughts even if they seem wrong — often a wrong approach illuminates the right one.\n\nWith consistent practice and these strategies, you'll be surprised how many \"impossible\" problems become solvable.",
        "createdAt": "2026-01-05T00:00:00.000Z"
    },
    {
        "id": "b5",
        "tag": "Python & Math",
        "date": "Dec 22, 2025",
        "readTime": "8 min read",
        "title": "How to Visualize Mathematical Functions with Python",
        "excerpt": "Matplotlib and NumPy make it incredibly easy to plot functions, surfaces, and data. Walk through creating beautiful math visualizations step by step.",
        "image": "",
        "link": "#",
        "content": "## Why Visualize Math?\n\nA picture is worth a thousand equations. Visualizing functions helps build intuition that algebraic manipulation alone can't provide. With Python's Matplotlib and NumPy, you can plot anything from simple curves to 3D surfaces in just a few lines.\n\n## Setting Up\n\nInstall the libraries:\n```\npip install matplotlib numpy\n```\n\n## Plotting a Simple Function\n\nPlot f(x) = sin(x) from -2π to 2π:\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.linspace(-2 * np.pi, 2 * np.pi, 500)\ny = np.sin(x)\n\nplt.figure(figsize=(10, 4))\nplt.plot(x, y, color='purple', linewidth=2)\nplt.title('f(x) = sin(x)')\nplt.xlabel('x')\nplt.ylabel('f(x)')\nplt.grid(True, alpha=0.3)\nplt.axhline(0, color='black', linewidth=0.8)\nplt.show()\n```\n\n## Plotting Multiple Functions\n\n```python\ny1 = np.sin(x)\ny2 = np.cos(x)\ny3 = np.tan(x)\nplt.plot(x, y1, label='sin(x)')\nplt.plot(x, y2, label='cos(x)')\nplt.ylim(-2, 2)  # clip tan\nplt.legend()\n```\n\n## 3D Surface Plots\n\nVisualize f(x, y) = sin(√(x² + y²)):\n\n```python\nfrom mpl_toolkits.mplot3d import Axes3D\n\nx = np.linspace(-10, 10, 300)\ny = np.linspace(-10, 10, 300)\nX, Y = np.meshgrid(x, y)\nZ = np.sin(np.sqrt(X**2 + Y**2))\n\nfig = plt.figure(figsize=(10, 7))\nax = fig.add_subplot(111, projection='3d')\nax.plot_surface(X, Y, Z, cmap='viridis', alpha=0.85)\nplt.title('Ripple Surface')\nplt.show()\n```\n\n## Visualizing Vectors and Linear Transformations\n\nUse `plt.quiver()` to draw vectors. This is perfect for linear algebra: draw eigenvectors, show how a matrix transforms the unit square, or visualize gradient fields.\n\n## Conclusion\n\nVisualization transforms abstract mathematics into something you can *see* and *feel*. Whether you're studying limits, linear algebra, or differential equations, a quick Python plot can reveal structure that pages of algebra cannot.",
        "createdAt": "2025-12-22T00:00:00.000Z"
    },
    {
        "id": "b6",
        "tag": "Study Tips",
        "date": "Dec 10, 2025",
        "readTime": "3 min read",
        "title": "How I Stay Consistent With My Math Studies Every Day",
        "excerpt": "Consistency beats intensity. Here's my personal routine — from morning problem sets to evening review — that keeps me sharp and motivated as a math student.",
        "image": "",
        "link": "#",
        "content": "## The Biggest Mistake Math Students Make\n\nCramming. Most students study intensely before exams and then forget everything two weeks later. Mathematics is not a subject you can absorb in bursts — it's a skill that requires *daily* practice, even if it's just 30 minutes.\n\n## My Morning Routine (6:30 AM – 7:30 AM)\n\n**6:30 AM** — Wake up, quick breakfast, no phone for the first 20 minutes.\n\n**6:50 AM** — Review yesterday's notes for 10 minutes. This \"spaced repetition\" trick dramatically improves long-term retention.\n\n**7:00 AM** — Solve 2–3 practice problems from the current topic. Morning is when my mind is sharpest.\n\n**7:30 AM** — Read ahead in the textbook for 10 minutes — just enough to prime my brain for the day's lectures.\n\n## The Afternoon Session (4:00 PM – 6:00 PM)\n\nDeep work time. I tackle the hardest problems here — proofs, new concepts, problem sets. I use the Pomodoro technique: 25 minutes focused work, 5 minutes break.\n\nI also keep a \"mistake journal\" — every time I get something wrong, I write down why in my own words. This forces understanding, not just memorization.\n\n## Evening Wind-Down (9:00 PM – 9:30 PM)\n\nLight review only. I go through flashcards (I use Anki) for 20 minutes, then write three things I learned today. This reflection step cements memory.\n\n## Weekend Strategy\n\nSaturday is for problem-solving marathons — past exam papers, olympiad problems, hard textbook exercises.\nSunday is for conceptual review — re-reading theory, watching explanatory videos, linking ideas together.\n\n## The Secret\n\nShow up every day, even when you don't feel like it. A 20-minute session on a bad day is still better than no session at all. Mathematics rewards persistence above all else.",
        "createdAt": "2025-12-10T00:00:00.000Z"
    },
    {
        "id": "b7",
        "tag": "Number Theory",
        "date": "Nov 28, 2025",
        "readTime": "6 min read",
        "title": "The Beauty of Prime Numbers: Patterns in the Infinite",
        "excerpt": "Primes seem random, yet they follow deep and surprising patterns. From the Sieve of Eratosthenes to the Riemann Hypothesis — a tour of prime number theory.",
        "image": "",
        "link": "#",
        "content": "## What Makes Primes Special?\n\nA prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The first few primes are: 2, 3, 5, 7, 11, 13, 17, 19, 23…\n\nOn the surface, primes look random. But they hide extraordinary patterns that mathematicians have been unraveling for centuries.\n\n## The Infinitude of Primes\n\nEuclid proved around 300 BCE that there are infinitely many primes. His proof is one of the most elegant in all of mathematics:\n\n*Suppose there are finitely many primes p₁, p₂, …, pₙ. Let N = p₁·p₂·…·pₙ + 1. Then N is divisible by none of the pᵢ, so N is either prime itself or has a prime factor not in our list — contradiction.*\n\n## The Sieve of Eratosthenes\n\nAn ancient algorithm for finding all primes up to n:\n1. List numbers 2 to n\n2. Start at 2 — mark all multiples of 2 as composite\n3. Move to next unmarked number (3) — mark its multiples\n4. Repeat until you've processed √n\n5. Remaining unmarked numbers are prime\n\n## Prime Gaps and Twin Primes\n\nPrimes get sparser as numbers grow larger — the gaps between them increase on average. Yet we still find \"twin primes\" like (11, 13), (17, 19), (41, 43). The Twin Prime Conjecture states there are infinitely many such pairs — but this remains unproven!\n\n## The Prime Number Theorem\n\nThe density of primes near a large number N is approximately 1/ln(N). This means the number of primes up to N is approximately N/ln(N) — a remarkable and beautiful result.\n\n## The Riemann Hypothesis\n\nThe most famous unsolved problem in mathematics. The Riemann Zeta function ζ(s) has deep connections to the distribution of primes. The hypothesis states that all non-trivial zeros of ζ(s) have real part 1/2. Proving (or disproving) this would win you a $1 million Millennium Prize.\n\n## Conclusion\n\nPrime numbers are the atoms of arithmetic — everything is built from them, yet they themselves resist complete understanding. That's what makes them so captivating.",
        "createdAt": "2025-11-28T00:00:00.000Z"
    },
    {
        "id": "b8",
        "tag": "Differential Equations",
        "date": "Nov 15, 2025",
        "readTime": "7 min read",
        "title": "From Population Growth to Pendulums: Real-World Differential Equations",
        "excerpt": "Differential equations model change — and change is everywhere. Discover how ODEs describe population dynamics, cooling, radioactive decay, and oscillation.",
        "image": "",
        "link": "#",
        "content": "## What Is a Differential Equation?\n\nA differential equation is an equation that relates a function to its derivatives. It describes how something *changes* over time (or space).\n\n**dy/dt = f(t, y)**\n\nThe field splits into:\n- **ODEs** (Ordinary Differential Equations) — one independent variable\n- **PDEs** (Partial Differential Equations) — multiple independent variables\n\n## Example 1: Exponential Growth & Decay\n\nIf a population grows proportionally to its size:\n\n**dP/dt = kP**\n\nSolution: **P(t) = P₀ · eᵏᵗ**\n\nWith k > 0, population grows exponentially. With k < 0, it decays — this models radioactive decay, where k = −λ (the decay constant).\n\n## Example 2: Newton's Law of Cooling\n\nAn object cools at a rate proportional to the difference between its temperature T and room temperature Tᵣ:\n\n**dT/dt = −k(T − Tᵣ)**\n\nSolution: **T(t) = Tᵣ + (T₀ − Tᵣ)e⁻ᵏᵗ**\n\nThis tells you how quickly your coffee cools — and is used in forensics to estimate time of death.\n\n## Example 3: The Simple Harmonic Oscillator\n\nA pendulum (small angle approximation) or mass-spring system satisfies:\n\n**d²x/dt² + ω²x = 0**\n\nSolution: **x(t) = A·cos(ωt) + B·sin(ωt)**\n\nPure oscillation — the foundation of wave mechanics.\n\n## Example 4: The Logistic Model\n\nExponential growth can't continue forever. The logistic equation adds a carrying capacity K:\n\n**dP/dt = rP(1 − P/K)**\n\nThis gives an S-shaped (sigmoid) growth curve — far more realistic for populations.\n\n## Solving ODEs\n\nMethods include:\n- Separation of variables\n- Integrating factors\n- Undetermined coefficients\n- Variation of parameters\n- Numerical methods (Euler, Runge-Kutta)\n\n## Conclusion\n\nDifferential equations are the language of physics, biology, economics, and engineering. Learning to read and solve them opens up entire worlds of mathematical modeling.",
        "createdAt": "2025-11-15T00:00:00.000Z"
    },
    {
        "id": "b9",
        "tag": "Real Analysis",
        "date": "Nov 2, 2025",
        "readTime": "8 min read",
        "title": "What Is Rigor? A First Look at Mathematical Proof",
        "excerpt": "Why do mathematicians insist on proofs? What makes a mathematical argument valid? A beginner-friendly introduction to the culture of rigorous reasoning.",
        "image": "",
        "link": "#",
        "content": "## The Question Every Student Asks\n\n\"Why do we need to *prove* this? It's obviously true!\"\n\nThe history of mathematics is littered with \"obvious\" statements that turn out to be false, and strange statements that turn out to be true. Rigor exists because intuition lies.\n\n## What Is a Proof?\n\nA mathematical proof is a logical argument that establishes a statement as definitely true, using only:\n1. Definitions\n2. Axioms (assumed truths)\n3. Previously proven theorems\n4. Rules of logical inference\n\n## Types of Proof\n\n**Direct Proof:** Assume the hypothesis, chain logical steps to the conclusion.\n\nExample: Prove that if n is even, then n² is even.\n*Proof:* If n is even, n = 2k for some integer k. Then n² = 4k² = 2(2k²), which is even. □\n\n**Proof by Contradiction:** Assume the statement is false and derive a contradiction.\n\nExample: Prove √2 is irrational.\n*Proof:* Suppose √2 = p/q in lowest terms. Then 2 = p²/q², so p² = 2q², meaning p² is even, so p is even. Write p = 2m. Then 4m² = 2q², so q² = 2m², meaning q is also even. But then p/q is not in lowest terms — contradiction. □\n\n**Proof by Induction:** Prove a base case, then prove the step from n to n+1.\n\n**Proof by Contrapositive:** Instead of proving P → Q, prove (¬Q → ¬P), which is logically equivalent.\n\n## The ε-δ Definition of Limits\n\nThis is where most students first encounter full mathematical rigor:\n\n**lim (x → a) f(x) = L** means:\n*For every ε > 0, there exists δ > 0 such that if 0 < |x − a| < δ, then |f(x) − L| < ε.*\n\nThis precisely captures \"f(x) gets arbitrarily close to L as x gets close to a\" without any vague language.\n\n## Why Rigor Matters\n\nIn 1821, Cauchy published a \"theorem\" that a uniform limit of continuous functions is continuous. In 1826, Abel found a counterexample. The flaw: Cauchy confused pointwise and uniform convergence.\n\nRigor prevents such mistakes. It forces you to pin down exactly what you mean — and that precision is what makes mathematics reliable.\n\n## Conclusion\n\nEmbracing rigor doesn't make math harder — it makes it *clearer*. Once you start writing proofs, you realize that mathematics is less about calculation and more about understanding *why* things are true.",
        "createdAt": "2025-11-02T00:00:00.000Z"
    },
    {
        "id": "b10",
        "tag": "Calculus",
        "date": "Oct 20, 2025",
        "readTime": "5 min read",
        "title": "Integration by Parts: The LIATE Rule Explained",
        "excerpt": "Integration by parts is one of the most powerful techniques in calculus. Learn the LIATE trick to choose u and dv, and see it applied to tricky integrals.",
        "image": "",
        "link": "#",
        "content": "## The Integration by Parts Formula\n\nDerived from the product rule for differentiation:\n\n**∫ u dv = uv − ∫ v du**\n\nThe challenge is always choosing which part of the integrand to call u and which to call dv.\n\n## The LIATE Rule\n\nLIATE is a priority order for choosing u:\n\n- **L** — Logarithms (ln x, log x)\n- **I** — Inverse trig functions (arctan x, arcsin x)\n- **A** — Algebraic functions (x², x³, polynomials)\n- **T** — Trigonometric functions (sin x, cos x)\n- **E** — Exponential functions (eˣ, 2ˣ)\n\nChoose *u* as the function that appears earliest in the list.\n\n## Example 1: ∫ x·eˣ dx\n\nu = x (Algebraic — comes before Exponential in LIATE)\ndv = eˣ dx → v = eˣ\n\n∫ x·eˣ dx = x·eˣ − ∫ eˣ dx = x·eˣ − eˣ + C = eˣ(x − 1) + C\n\n## Example 2: ∫ x·sin(x) dx\n\nu = x (Algebraic)\ndv = sin(x) dx → v = −cos(x)\n\n∫ x·sin(x) dx = −x·cos(x) + ∫ cos(x) dx = −x·cos(x) + sin(x) + C\n\n## Example 3: ∫ ln(x) dx\n\nu = ln(x) (Logarithm — top priority)\ndv = dx → v = x\n\n∫ ln(x) dx = x·ln(x) − ∫ x · (1/x) dx = x·ln(x) − x + C\n\n## The \"Cycling\" Trick\n\nSome integrals like ∫ eˣ·sin(x) dx require integration by parts twice and then solving for the integral:\n\nLet I = ∫ eˣ·sin(x) dx. Apply by parts twice, and you get:\nI = eˣ·sin(x) − eˣ·cos(x) − I\n2I = eˣ(sin(x) − cos(x))\nI = eˣ(sin x − cos x)/2 + C\n\n## Conclusion\n\nIntegration by parts is an essential tool in any mathematician's or engineer's toolkit. With the LIATE rule as your guide, choosing u becomes almost automatic, and complex integrals yield to systematic attack.",
        "createdAt": "2025-10-20T00:00:00.000Z"
    },
    {
        "id": "b11",
        "tag": "Statistics",
        "date": "Oct 8, 2025",
        "readTime": "6 min read",
        "title": "Bayes' Theorem: The Math Behind Rational Belief Updating",
        "excerpt": "Bayes' Theorem is one of the most useful formulas in statistics and science. Learn how to update beliefs with evidence, and why this matters so much in data science.",
        "image": "",
        "link": "#",
        "content": "## The Core Idea\n\nBayes' Theorem tells us how to update our belief in a hypothesis H given new evidence E:\n\n**P(H|E) = P(E|H) · P(H) / P(E)**\n\n- **P(H)** — Prior: our initial belief in H before seeing evidence\n- **P(E|H)** — Likelihood: how probable is the evidence if H is true?\n- **P(H|E)** — Posterior: our updated belief after seeing E\n- **P(E)** — Normalizing constant (total probability of E)\n\n## A Classic Example: Medical Testing\n\nSuppose a disease affects 1% of the population. A test is 99% sensitive (true positive rate) and 99% specific (true negative rate).\n\nYou test positive. What's the probability you actually have the disease?\n\nLet H = \"have disease\", E = \"test positive\".\n\nP(H) = 0.01\nP(E|H) = 0.99\nP(E|¬H) = 0.01 (false positive rate)\nP(E) = P(E|H)·P(H) + P(E|¬H)·P(¬H) = 0.99×0.01 + 0.01×0.99 = 0.0198\n\nP(H|E) = (0.99 × 0.01) / 0.0198 ≈ **50%**\n\nSurprising! Even with a highly accurate test, a positive result for a rare disease is only 50% reliable — because the false positives swamp the true positives.\n\n## Why This Matters\n\nThis example has profound implications for medicine, law, and everyday reasoning. It's why universal screening for rare conditions can be problematic even with excellent tests.\n\n## Bayesian vs. Frequentist Statistics\n\nThe frequentist approach treats probability as a long-run frequency. The Bayesian approach treats probability as a *degree of belief* that updates with evidence. Modern data science and machine learning use both — but Bayesian methods are especially powerful when data is limited.\n\n## Applications\n\n- **Spam filtering**: Update the probability an email is spam based on word frequencies\n- **Medical diagnosis**: Combine test results with prevalence rates\n- **Machine learning**: Bayesian neural networks, Gaussian processes\n- **A/B testing**: Bayesian A/B tests give probabilities, not just p-values\n\n## Conclusion\n\nBayes' Theorem is remarkably simple yet endlessly deep. Once you internalize it, you start seeing probability updating everywhere — from detecting fraud to forecasting weather to forming rational beliefs.",
        "createdAt": "2025-10-08T00:00:00.000Z"
    },
    {
        "id": "b12",
        "tag": "Linear Algebra",
        "date": "Sep 25, 2025",
        "readTime": "7 min read",
        "title": "Why Matrices Are Linear Transformations (Not Just Arrays of Numbers)",
        "excerpt": "Most students think of matrices as grids of numbers for computation. But the real insight is geometric: matrices *transform* space. Here's the linear algebra mindset shift.",
        "image": "",
        "link": "#",
        "content": "## The Standard View: Computation\n\nMost introductions to matrices focus on operations: addition, multiplication, inverses. This is useful, but misses the deeper picture.\n\n## The Better View: Transformation\n\nEvery matrix A represents a **linear transformation** — a function that maps vectors to vectors while preserving:\n1. Addition: T(u + v) = T(u) + T(v)\n2. Scalar multiplication: T(cu) = c·T(u)\n\nWhen you compute Av, you're transforming vector v using the transformation encoded in A.\n\n## Column Picture\n\nIf A = [v₁ | v₂ | … | vₙ] (columns), then:\n\n**Ax = x₁v₁ + x₂v₂ + … + xₙvₙ**\n\nSo Ax is a *linear combination* of A's columns, weighted by the components of x. The image of A is the span of its columns.\n\n## Geometric Meaning of Key Operations\n\n**Determinant:** The factor by which A scales areas (2D) or volumes (3D). det(A) = 0 means A squashes space into lower dimension (not invertible).\n\n**Inverse:** Undoes the transformation. A⁻¹ carries transformed vectors back to originals.\n\n**Transpose:** Swaps rows and columns. For orthogonal matrices, transposing equals inverting — the transformation is \"pure rotation\" or \"pure reflection.\"\n\n**Rank:** The dimension of the image (column space). Rank = n means the transformation preserves all dimensions. Rank < n means information is lost (projection into lower space).\n\n## The Four Fundamental Subspaces\n\nEvery matrix has four fundamental subspaces:\n1. **Column space** (image): where Av can land\n2. **Null space** (kernel): vectors that A sends to zero\n3. **Row space**: orthogonal complement of the null space\n4. **Left null space**: orthogonal complement of the column space\n\n## Why This Mindset Matters\n\nWith the transformation view:\n- Eigenvalues become natural (directions that don't rotate)\n- SVD becomes geometric (stretch in orthogonal directions)\n- Neural networks are sequences of transformations\n- Computer graphics is built on matrix transformations\n\n## Conclusion\n\nStart thinking of every matrix as a transformation of space. This shift in perspective transforms linear algebra from a collection of algorithms into a profound geometric theory — and makes every subsequent concept click into place.",
        "createdAt": "2025-09-25T00:00:00.000Z"
    }
]